{"pages":[{"title":"","text":"[{\"name\":\"DASHENG-900x700-1.png\",\"date\":1518959551960},{\"name\":\"DASHENG-900x700-2.png\",\"date\":1518959599098},{\"name\":\"DASHENG-900x700-3.png\",\"date\":1518959609913},{\"name\":\"DASHENG-900x700-4.png\",\"date\":1518959618105}]","link":"/hexo-admin-ehc-images.json"},{"title":"About","text":"合阳鬼，长安居，学无成，艺不精，然有一身好膘。","link":"/about/index.html"},{"title":"Categories","text":"","link":"/categories/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Kotlin","text":"狗日的又出新东西了","link":"/2017/05/18/Kotlin/"},{"title":"重新整理博客","text":"2021 就要结束了， 重新看下这个博客，像找到一个丢弃在角落里很久没有玩的玩具，掸去积尘，擦的干净一些，想起自己曾经多么在意它，花费时间处理问题，找皮肤装扮，编辑标签，整理文章，还在issues 里面记录了很多有意思的想法。忽而又好像随手丢弃再也不顾，回头翻看，都是三年前所思所想，不胜唏嘘。之前用的CI工具已经不免费了，重新将网站调整为github action 来进行部署。仍旧可以直接在网页上面来写文章。只是github 网络不稳定，最好还是现在本地写一份，然后直接贴上去。中间还买过一次自己的域名和主机，想用wordpress交互体验更好一些。可惜心志薄弱，用了一年之后就不了了之，这算是第二次搭建博客失败。Github 的个人主页倒是不存在这些问题，可能一百年之后它还存在，一个纯粹的静态网页。","link":"/2021/12/20/2021/"},{"title":"用Ipad画画","text":"买了一个类纸膜，用IPAD画个草图看看","link":"/2021/12/23/My desk/"},{"title":"Weekly Update 2019-7-13","text":"I will intruduc a youtube subscribers TechLead.a very cool software engineer, maybe a american japanese. very handsome.https://www.youtube.com/channel/UC4xKdmAXFh4ACyhpiQ_3qBw ToolsGrammarly for Chrome Book`I found an interesting book: 设计方法卡牌","link":"/2019/07/13/Weekly-Update-2019-7-13/"},{"title":"First video","text":"Although think a lot in half-year, but only record a junior video finally.So hope this is a good start, and I plan to record weekly.","link":"/2019/07/17/first-video/"},{"title":"gulp 常用工具指南","text":"最近gulp用的比较多，总结一下。","link":"/2017/05/18/gulp/"},{"title":"hexo","text":"记录和hexo 相关事情 hexo seohexo seo2","link":"/2017/06/04/hexo/"},{"title":"影评之前","text":"大概是上中学看第十放映室的影响，总想着写个影评，学着像个聪明人，点评这世间的饮食男女，光陆怪离。到在外面上学时间多起来的时候，每每想写点啥，却发现做这个聪明人还有点门槛，最起码得记得住情节，进阶点的还需要点电影知识，什么人物，地名，道具造型，灯光镜头，或是风格流派。我曾揣测，那些电影学院里面的学生们，看电影的时候得带个小本子，坐在黑漆漆的影院里，在本子上面记录着观影的信息。想来影院光线太暗，记录的东西只有自己能够看明白，回到宿舍还得再整理一遍。有些个估计还得找到片源，一帧帧的找到印象中的场景，记录电影中的台词。有些片子又涉及到历史政治，音乐文化，写篇影评估计得在图书馆里呆着了。看电影这娱乐的事情，顿时变得沉重起来。聪明人我是学不来了，只好吃着薯片，看个热闹，了事翻翻豆瓣影评，看电影时隐隐约约的一些想法，多数可以在别人的点评找到点确凿的文字。但是在没有看到这文字之前，我断然是不知道自己的想法是这样的，只有明确的看到了别人的描述，心中一亮，“呀，我也是这样想的”。久而久之，我便认清了自己的水平和面目，好在周围也无人和我讨论这些事情，可以藏着自己的浅陋，一晃好些年，什么也没写。 忽的有了好些时间，我又想捡起来这曾想做却一直没有做的事情，就算是小学生的观后感也无所谓，毕竟不用担心交不了作业和老师的批阅了。","link":"/2017/07/29/movie/"},{"title":"暴雪将至","text":"看的时候觉得大家都是劳模-我去年也被评为劳模，劳模惜劳模，自以为很能理解余国伟的隐忍，坚持，模糊的感情，以及绝望和失落。看完后，走出影院的时候又想，即便这高楼大厦若干年后真的塌掉了，现在还是得过现在的生活。暴雪将至，大厦将倾。再过活一次，余国伟还是那个追求着劳模奖章和痴迷于转正公安局的认真的余国伟。什么都不会改变，直到大雪将这世界掩埋","link":"/2018/01/13/movies/"},{"title":"如何显示乐谱","text":"2018-12-03 更新 初步结论，在乐谱的web化显示上面有成熟的开源解决方案。可以在其中选择一种使用。 我计划对乐谱展现 方向的资料做一下整理，以完善这个课题。 更新一下这个方向资料。 目前看起来还是有很多软件和第三方开源的来进行乐谱的显示，不过国内还是没有看到基于 乐谱的 平台性质的 产品出现。 flat.io flat 官方提供的几个项目也是不错的学习资料 FlatIO/embed-client: 🎼 Sheet Music &amp; Tabs Embed JavaScript Client Embed sheet music and tabs on your website or blog - Flat tananamusic musicxml 方向MusicXML简明教程_百度文库 我没看明白这个是做什么的 scratch-singer | Convert a scratch project file to a MusicXML for Sinsy (Singing Voice Synthesis) 比较靠谱的几个vexTab 初步看起来也很有价值,可以给吉他打谱子 alphaTab – music notation for everyone VexFlow - HTML5 Music Engraving opensheetmusicdisplay opensheetmusicdisplay 介绍自己是musicxml 和 vexflow 之间的桥梁，应该是基于vexflow 的实现版本 pikkle/vexmxl: A tool to translate MusicXML to VexTab (allowing both tablatures and music sheets) bneumann/vexflow-musicxml: VexFlow backed MusicXML parser kylestetz/lissajous: A tool for programmatic audio performance in the browser using Javascript. Extractab 解决编辑问题VexUI by andrebakker MIDI 方向FlatIO/midijs: 🎹 Parser and encoder for MIDI events and Standard MIDI files grimmdude/MidiWriterJS: ♬ A JavaScript library which provides an API for programmatically generating and creating expressive multi-track MIDI files and JSON objects. music-l10n/experiments/sheet-player at master · infojunkie/music-l10n danigb/soundfont-player: Quick soundfont loader and player for browser 其他 web audio 方向有趣的Tonejs/Tone.js: A Web Audio framework for making interactive music in the browser. kylestetz/lissajous: A tool for programmatic audio performance in the browser using Javascript. Project Audio for GitHub mouse-reeve/infinite_gnossienne: An endless version of Erik Satie’s Gnossiennes No. 1 有键盘 Tonal App 生产随机音乐Ghrehh/eartraining: Web app that generates random musical intervals to help you train your ear. Uses VexFlow and AudioSynth JS. 钢琴键盘的展示Musical Keyboard - JS Dynamic Audio Synth 其他乐谱方向初步认为是一个基于vextab 的 在线 五线谱编辑器 abc | home 关于音乐方面的有趣的项目列表ciconia/awesome-music: Awesome Music Projects 一些音乐播放器SmallRuralDog/electron-vue-music: 基于 electron-vue 开发的音乐播放器，界面模仿QQ音乐，技术栈electron-vue+vue+vuex+vue-router+element- UI。欢迎star Practice Sight Reading and Sight Singing Exercises Online – Sight Reading Factory® nuclear music player naomiaro/waveform-playlist: Multitrack Web Audio editor and player with canvas waveform preview. Set cues, fades and shift multiple tracks in time. Record audio tracks or provide audio annotations. Export your mix to AudioBuffer or WAV! Project inspired by Audacity. 新闻类Top 7 Guitar Tab App for iOS and Android","link":"/2018/12/03/music/"},{"title":"unity 站点导航","text":"Unity3D 项目用 git 做版本控制 - u012169685的博客 - 博客频道 - CSDN.NET 朱峰社区_3dmax教程_maya教程_3dmax视频教程——中国最好的3dmax教程网【游戏蛮牛】-虚拟现实,unity3d,unity3d教程下载首选u3d,unity3d官网 CGJOY大师孵化器 专业游戏特效师、游戏动画师交流社区。是游戏美术设计师实现梦想的地方 - Powered by Discuz!CG游麟网 - 最专业的游戏美术制作交流平台 【【Unity3D】完整RPG《海战》手机游戏源码】-项目源码-【游戏蛮牛】-ar增强现实,虚拟现实,unity3d,unity3d教程下载首选u3d,unity3d官网 【unity3d中国054a型军舰模拟海战demo，exe无源码，船舶控制调试了2天2夜】-项目源码-【游戏蛮牛】-ar增强现实,虚拟现实,unity3d,unity3d教程下载首选u3d,unity3d官网 学习网站siki学院 - Unity游戏开发从入门到独立开发","link":"/2017/07/20/unity/"},{"title":"常用站点","text":"http://sivalabs.in/ http://www.dzone.comDzone为全球的软件开发者和软件工程师们开发与发布珍贵的软件方面的相关内容和信息。15年来，Dzone用它诚实的品质、产品和资源分享服务赢得了顾客的信任和热爱，而且会继续为顾客带来巨大的影响。DZone坐落在美国新喀里多尼亚的加利地区，为全球的机构组织和软件开发者提供服务。 https://www.infoq.com http://www.51cto.com/ 工具篇http://www.generatedata.com/ https://zeplin.io/ 在线学院https://www.codeschool.com/ https://cn.udacity.com/ https://teamtreehouse.com/ https://frontendfront.com/ https://www.lynda.com/ http://www.tutorialspoint.com/index.htm https://www.codecademy.com https://www.coursera.org/ http://www.sololearn.com/ https://www.udemy.com 技术问答http://stackoverflow.com/ https://community.oracle.com/community/java https://azure.microsoft.com/en-us/develop/java/ http://www.javaworld.com/ 站点列表http://webdevchecklist.com/","link":"/2017/01/15/website/"},{"title":"Web Security","text":"记录web 安全问题，常更。 2017-06-04 13:13:11https://github.com/qazbnm456/awesome-web-security","link":"/2017/06/04/web安全/"},{"title":"统一工作栈","text":"发现需要平时涉及的面有些太宽，实际工作中做的事情和下班后练习的东西之间没有太多关系。 需要做一下调整，统一工作栈。 统一工作栈： 1： 总体思路，练习和生产相分离。不要在生产环境中进行练习。 如果确定做一个项目就使用已经掌握的技术来做，项目中遇到问题可以公关。 对于没有掌握的技术，采用练习项目来做，练习到一定程度在应用到实际工作中。 2： 下班之后自己做的小项目和实际工作中的项目技术上基本对齐，做到相辅相成。提高效率。","link":"/2017/05/19/统一工作栈/"},{"title":"多媒体","text":"估计这辈子都不会碰的好玩的方向： 音乐： https://learningmusic.ableton.com/","link":"/2017/06/04/多媒体/"},{"title":"chrome markdown tools","text":"chrome 网页地址保存为 markdown 模式 我需要一个chrome 工具，用来收藏网页地址，并且将它转化为markdown的模式。这也可以提高写markdown 文件的速度例如有一个地址是网页是 http://www.baidu.com 并且它的title是 百度 ，那么点击工具按钮之后就生成了一个字符串 1[百度]( http://www.baidu.com) 2017-06-11 21:06:20 search at chrome web store,already have some extensions : Copy as Markdown:https://chrome.google.com/webstore/detail/copy-as-markdown/fkeaekngjflipcockcnpobkpbbfbhmdn?utm_source=chrome-ntp-icon Copy title and url as Markdown stylehttps://chrome.google.com/webstore/detail/copy-title-and-url-as-mar/fpmbiocnfbjpajgeaicmnjnnokmkehil?utm_source=chrome-ntp-icon find a image store https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf/related?utm_source=chrome-ntp-icon","link":"/2017/06/10/IDEA/chromemarkdown/"},{"title":"删除冗余图片","text":"2017-06-03 23:57:25 这两天和大芒果讨论了一下关于在项目中清除冗余图片的问题，之前没有关注到这块，整理一下在这个方面搜集到的资料。 2017-06-04 10:48:01清除冗余是一个有意思的问题，同理可以衍生出一些其他的可以操作的比如清除冗余的CSS。清除冗余js方法等等。另外这个问题的场景比较固定，只考虑在前端静态页面开发过程中引入的图片资源问题。如果扩散一下删除冗余图片的问题可能会复杂些，例如：如何删除博客上传的冗余图片 知乎上面的这个问题 当然好像都有解决方案 gulp-unused-images gulp-delete-unused-images 有位兄台用Python 写了个方法文章 2017-06-04 18:56:59 我们想了在webpack上面实现这个功能,当然也有人关注到这个方面 unused-files-webpack-plugin","link":"/2017/06/04/IDEA/cleanimage/"},{"title":"disqus","text":"目前网站用的留言系统是disqus的，以前做FIGE的时候就用的，一晃都六七年光景了。 国内的留言系统看了下都没有做起来，或者做的我自己觉得有点挫。这个地方应该可以做点东西。","link":"/2017/06/12/IDEA/disqus/"},{"title":"math web","text":"MathType (数学公式编辑器) 在网页上面显示数学公式，看起来可以做一个比较好的APP 来处理这个事情。 在网页中写入数学公式 - ZQ是水鱼 - 博客园 数学公式生成器 - 互联网小程序 - 阮一峰的个人网站 科学网—如何在网页中写数学公式 - 彭海杰的博文 有node方面的资源mathjax/MathJax-node: MathJax for Node 不必像 daum 的这种用flash 来实现Daum Equation Editor 甚至可以生成 一份图像 2D or 3Dgraph.tk 在网页中显示数学公式_百度文库这有一个网站： 在网页上使用数学公式的各种方法 高中数学-菁优网 [转载]网页插入复杂数学公式Uranus1新浪博客 几个APP:AsciiMath 这个是老外的一个实现 jsMath (Examples): Applied Complex Analysis Examples OMG! 这个网站和我的想法一样,只是丑了点Online LaTeX Equation Editor - create, integrate and download看看，有人和我想法一样，已经实现了。贴一个昨天用到的公式：","link":"/2017/06/13/IDEA/mathweb/"},{"title":"Machine-Learning","text":"凑个热闹, 入门机器学习101：我们天天都在说的机器学习，究竟该怎么入门？ 机器学习的最佳入门学习资源 黄泽武:http://www.jianshu.com/u/335306f03fb9 online：stanford cs229： http://cs229.stanford.edu/ Andrew Ng:斯坦福大学公开课 ：机器学习课程http://open.163.com/special/opencourse/machinelearning.html blogs机器学习 - 标签 - Bioinformation - 博客园独家 | 一文读懂特征工程 BookPython机器学习实践指南-图书 - 异步社区 website资源 | 深度学习入门和学习书籍「机器学习」和「深度学习」的 Cheat Sheets - 知乎专栏12 个免费的 Deep Learning 在线学习网站 - 知乎专栏 software：matlab：https://cn.mathworks.com/products/matlab.html octave：http://www.gnu.org/software/octave/#source 看到一个视频一个女孩子都在玩的，我却自觉屏蔽，惭愧。 refresh time: 2017-06-04 12:34:35","link":"/2017/06/12/Machine-learning/machine-learning/"},{"title":"octive","text":"入门： 机器学习入门(9)–Octave入门 Octave入门 - 小菜鸟的起飞之路 - 博客频道 - CSDN.NET http://blog.csdn.net/cstopcoder/article/details/40477431 这篇讲的好 Octave入门 - Bioinformation - 博客园 在线版本： https://octave-online.net/ angles=linspace(0,2*pi,100),y=sin(angles),plot(angles,y) 2x-y=0plot(x,y)","link":"/2017/06/12/Machine-learning/octive/"},{"title":"MongoDB","text":"MongoDB以BSON格式的文档（Documents）形式存储。Databases中包含集合（Collections），集合（Collections）中存储文档（Documents）。 BSON是一个二进制形式的JSON文档，它比JSON包含更多的数据类型。对于BSON规格，可参见bsonspec.org，也可参考BSON类型。 Databases 在MongoDB中，databases保存文档（Documents）的集合（Collections）。 在Mongo Shell中，通过使用use 命令来选中database，就像下面的例子： use myDB创建Database 如果database不存在，MongoDB会在第一次为database存储数据的时候创建。因此，你可以直接切换到一个不存在的数据库，然后执行下面的语句： use myNewDB db.myNewCollection1.insert( { x: 1 } )insert()操作会创建名为myNewDB的database和名为myNewCollection1的collection（如果他们不存在的话）。 Collections MongoDB在collections中存储文档（documents）。Collections类似于关系型数据库中的表（tables）。 创建Collection 如果collection不存在，MongoDB会在第一次为collection存储数据的时候创建。 db.myNewCollection2.insert( { x: 1 } )db.myNewCollection3.createIndex( { y: 1 } )无论是insert()还是createIndex()操作，都会创建它们各自指定的收集，如果他们不存在的话。 显式创建 MongoDB提供db.createCollection()方法来显式创建一个collection，同时还能设置各种选项，例如：设置最大尺寸和文档校验规则。如果你没有指定这些选项，那么你就不需要显式创建collection，因为MongoDB会在你创建第一个数据的时候自动创建collection。 若要修改这些collection选择，可查看collMod。 Documents校验 3.2.x版本新增内容。 默认情况下，collection不要求文档有相同的结构；例如，在一个collection的文档不必具有相同的fields，对于单个field在一个collection中的不同文档中可以是不同的数据类型。 从MongoDB 3.2开始，你可以在对collection进行update和insert操作的时候执行文档（documents）校验规则。具体可参见文档验证的详细信息。 Documents Document结构 MongoDB的文件是由field和value对的结构组成，例如下面这样的结构： { field1: value1, field2: value2, field3: value3, … fieldN: valueN}value值可以是任何BSON数据类型，包括：其他document，数字，和document数组。 例如下面的document，包含各种不同类型的值： var mydoc = { _id: ObjectId(“5099803df3f4948bd2f98391”), name: { first: “Alan”, last: “Turing” }, birth: new Date(‘Jun 23, 1912’), death: new Date(‘Jun 07, 1954’), contribs: [ “Turing machine”, “Turing test”, “Turingery” ], views : NumberLong(1250000)}上面例子中的各fields有下列数据类型： _id：ObjectId类型name：一个嵌入的document，包含first和last字段birth和death：Date类型contribs：字符串数组views：NumberLong类型Field名 Field名是一个字符串。 Documents中的filed名有下列限制： _id被保留用于主键；其值必须是集合中唯一的、不可变的、并且可以是数组以外的任何数据类型不能以美元符号$开头不能包含点字符.不能包含空字符Field Value限制 对于索引的collections，索引字段中的值有最大长度限制。详情请参见Maximum Index Key Length。 圆点符号 MongoDB中使用圆点符号.访问数组中的元素，也可以访问嵌入式Documents的fields。 Arrays数组 通过圆点符号.来链接Arrays数组名字和从0开始的数字位置，来定位和访问一个元素数组： “.“举例：对于下面的document： { … contribs: [ “Turing machine”, “Turing test”, “Turingery” ], …}要访问contribs数组中的第三个元素，可以这样访问： “contribs.2”嵌入式Documents 通过圆点符号.来链接嵌入式document的名字和field名，来定位和访问嵌入式document： “.“举例：对于下面的document： { … name: { first: “Alan”, last: “Turing” }, …}要访问name中的last字段，可以这样使用： “name.last”Documents限制 Documents有下面这些属性和限制： Document大小限制 每个BSON文档的最大尺寸为16兆字节。 最大文档大小有助于确保一个单个文档不会使用过量的内存，或通信过程中过大的带宽占用。 若要存储超过最大尺寸的文档，MongoDB提供了GridFS API。可以看mongofiles和更多有关GridFS的文档 Document Field顺序 MongoDB中field的顺序默认是按照写操作的顺序来保存的，除了下面几种情况： _id总是document的第一个field可能会导致文档中的字段的重新排序的更新，包括字段名重命名。在2.6版本起，MongoDB开始积极地尝试保留document中field的顺序。 _id字段 _id字段有以下行为和限制： 默认情况下，MongoDB会在创建collection时创建一个_id字段的唯一索引id字段总是documents中的第一个字段。如果服务器接收到一个docuement，它的第一个字段不是id，那么服务器会将_id字段移在开头_id字段可以是除了array数组之外的任何BSON数据格式以下是存储_id值的常用选项： 使用ObjectId最好使用自然的唯一标识符，可以节省空间并避免额外的索引生成一个自动递增的数字。请参阅创建一个自动递增序列字段在您的应用程序代码中生成UUID。为了更高效的在collection和_id索引中存储UUID值，可以用BSON的BinData类型存储UUID。 大部分MongoDB驱动客户端会包含_id字段，并且在发送insert操作的时候生成一个ObjectId。但是如果客户端发送一个不带_id字段的document，mongod会添加_id字段并产生一个ObjectId *","link":"/2017/02/28/MongoDB/概述/"},{"title":"angular template","text":"recently I study some angualr template,so mark it in this post. 1. aspnetboilerplate.comThat’s what we’re using right now,angular is just the frontend part of it。 WebSite: 50+ Responsive Free AngularJS Admin Themes 2018 » CSS Author StartAngular | Free Angular Theme Dashboard Admin Template angular themes | WrapBootstrap 20+ AngularJS Admin Templates for Download - TemplateFlip 11 Free Responsive Angular 2 Admin Templates - Creative Tim’s Blog","link":"/2018/02/28/angular/uiframework/"},{"title":"Cloud Foundry","text":"Cloud Foundry是VMware推出的业界第一个开源PaaS云平台，它支持多种框架、语言、运行时环境、云平台及应用服务，使开发人员能够在几秒钟内进行应用程序的部署和扩展，无需担心任何基础架构的问题。同时，它本身是一个基于Ruby on Rails的由多个相对独立的子系统通过消息机制组成的分布式系统，使平台在各层级都可水平扩展，既能在大型数据中心里运行，也能运行在一台桌面电脑中，二者使用相同的代码库。[1]作为新一代云应用平台，Cloud Foundry专为私有云计算环境、企业级数据中心和公有云服务提供商所打造。Cloud Foundry云平台可以简化现代应用程序的开发、交付和运行过程，在面对多种公有云和私有云选择、符合业界标准的高效开发框架以及应用基础设施服务时，可以显著提高开发者在云环境中部署和运行应用程序的能力 Cloud Foundry是由相对独立的多个模块构成的分布式系统，每个模块单独存在和运行，各模块之间通过消息机制进行通信。Cloud Foundry各模块本身是基于Ruby语言开发的，每个部分可以认为拿来即可运行，不存在编译等过程。Cloud Foundry云平台整体逻辑组成如右下图所示：Cloud Foundry云平台逻辑视图Cloud Foundry云平台逻辑视图从图中可以看到，Cloud Foundry云平台是完全模块化的分布式系统，各个模块之间是相互独立的，通过消息总线进行相互连接和通信，这种结构不仅使系统各模块之间的耦合度降低，而且使系统功能容易扩充。此外，开发人员可以通过VMC命令行工具或STS插件方便的部署应用程序到Cloud Foundry云平台上，最终用户可以通过浏览器访问运行在Cloud Foundry云平台上的应用。所有的访问请求都通过Router进行转发，分别由云控制器Cloud Controller和应用运行代理DEA模块进行请求响应，应用生命周期管理Health Manager模块负责监控和管理整个应用在云平台上的正常运行，云平台的各种应用服务由Services模块提供，可以灵活扩展。Cloud Foundry云平台整体架构如右下图所示：[2]Cloud Foundry云平台整体架构Cloud Foundry云平台整体架构从图中可以看到，Cloud Foundry云平台主要有Router、Cloud Controller、Health Manager、DEA、NFS、NATS、Cloud Controller Database以及Service等模块组成。这些模块协同合作，通过特定的消息传输机制和API接口进行通信，就可以使整个云平台正常运行。由于在集群环境下每个模块都有多个部署节点，从而保证了云平台的可靠性和弹性动态扩展的需求，使得应用程序可以稳定可靠的运行在Cloud Foundry云平台上。[2] 相关连接 http://baike.baidu.com/link?url=GtPRRFoqg-UQcR0gD0owycwkzUC0UGEs2T5fCg_y8urZ_YwIl-juvVukdFAq8wIathvBfglSZ1sY0mrHDbyvVa","link":"/2017/01/02/cloud/CloudFoundry/"},{"title":"oocss","text":"http://www.w3cplus.com/css/oocss-concept http://www.oschina.net/question/179699_75159 “Object Oriented”直译就是面向对象，对于这个词，大家并不陌生，但是加上一个CSS也就是说Object Oriented CSS，对于这个还是第一次见过，被叫作OOCSS(面向对象的ＣＳＳ)，其实这个东西早在2008年被提出，有些同学也在自己的项目中用过了。但有很多同学并不清楚，就拿我来说，我一开始还以为OOCSS是一个新语言或者是CSS框架，其实都不是，他只不过是一种新的写法。那么下面就通过“什么是OOCSS”,“OOCSS理论”等几个部分和大家一起来学习OOCSS。","link":"/2017/01/02/css/oocss/"},{"title":"css 前沿技术","text":"CSS, Sass, SCSS, Compass, Less,BEM, SMACSS, OOCSS, ACSS, CCSS, WTFSS? http://www.w3cplus.com/css/css-sass-scss-compass-less-bem-smacss-oocss-acss-ccss-wtfss.html https://segmentfault.com/a/1190000000389838","link":"/2017/04/13/css/技术前沿/"},{"title":"how to writer math in html","text":"windows linux Test 在网页中写入数学公式 - ZQ是水鱼 - 博客园 数学公式生成器 - 互联网小程序 - 阮一峰的个人网站 科学网—如何在网页中写数学公式 - 彭海杰的博文","link":"/2017/06/11/diary/2017-6-11/"},{"title":"菊花茶","text":"前些日子家父给了我一袋菊花茶，应该是单位消暑发的绿色包装的贡菊。父亲说菊花茶性凉，他觉着自己喝着不好，就给我塞在书包里了。我自欣然接受，只是私下觉得有些惭愧，多年只是索取，未曾有半点报答。 我大概很少喝白开水，家里也有好些种冲泡的饮料。父亲给的红茶绿茶，还有一些自己买的橘子粉，咖啡，椰子粉之类，以前每到夏天就买一包橘子粉或酸梅粉，结果大多未能喝完过期扔掉了。其余的茶叶大多是父亲给的，很少自己去买，甚至不曾察觉茶叶是个消耗品。咖啡倒是自己买的，家里好像也就我自己喝，自己买，不过今年也喝的少些了。 回到基地办公之后，每天都泡茶喝，竟突然觉得茶叶消耗的快了起来，今年自己已经买了两包炒青，当然都是包装简易的超市货色。 茶水冲两三次就没了滋味，有了新的饮料就又天天泡菊花茶喝了，这贡菊每次放一两朵就好了，可能是我的口杯小的缘故，可以泡好几次。一开始不得法，总是多放了几朵，开始觉得有些甜，甚是好喝，后来竟越发觉得腻了。才发现原来放一两个就好了，甜只是后味。 不晓得这花朵儿泡茶是谁最先发明的，又附会了许多治疗的奇效。以前在莲湖的时候，楼下有一家花茶店铺，专门经营各类花茶。杭白、贡菊、胎菊、野菊、怀菊；各类的玫瑰，茉莉，罗汉果，还有百合，勿忘我。不晓得那店铺还在也不在，还有每周四赶集是的花市是不还依旧繁闹。 琐记。 刷新时间：2017-06-07 22:09:312017-06-08 23:01:00","link":"/2017/06/08/diary/2017-6-7/"},{"title":"2017","text":"2017年的 第二天， 2016年过的太忙碌，没有时间做任何事情，希望2017年能够好些。 2016年开始时的新奇与期望，在年末的时候都成了无尽的加班和工作，无力改变。","link":"/2017/01/02/diary/2017/"},{"title":"GitHUB is Free","text":"GitHUB is Free, I think this is the important things in this week. Last night, I tested it,github has changed a lot recently, I just find this new function statusThis is great era. This github`s blog talk about two things : 1. Github free 2. Github Enterprise Just in time, new company use github enterprise, before I use gitlabThis week is the first week of joining a new company,I was complete the e-learning training.Learned about finance.company culture,email security,and so on.I got a English Name, Will Wang, although I spend some time to find some name,like Vico, Vic, but in the end i chose the Will , I like it .","link":"/2019/01/13/diary/2019-1-13/"},{"title":"2019 Flags","text":"New year,new flags. For me, the most important thing ofcourse this year is to join a new team and switch to a new field.I hope to master the business as soon as possible, integrate into the new environment, and do my job best as before.Before ruanyifeng sent a tweet message, “in the current Internet age, if you did not make a voice on the network,Then you are a person who does not exist.” Although I am a programmer, a digital worker.But most of the time it was a consumer of onlineinformation, not a creator.This year I hope to make more voice on the Internet.Maybe I will write some blogs and record some video tutorials.Although the plan is written every year, many plans have not been completed.I still believe that step by step according to the plan, there will be a good result in the end.(This is for the company’s English Corner) Take part a full marathon Vocabulary over 8000+ Reading 12 peofessional books Record weekly status in english,maintain the Blog updates Have 1000+ fans in zhihu or weibo Reacording teaching vedio","link":"/2019/01/04/diary/2019-1-4/"},{"title":"测试自动部署问题","text":"好像文件修改不会发生变化，测试一下终于调通了太不容易了， 参考如下文章： https://levirve.github.io/2016/hexo-deploy-through-travisci/ 得写个邮件感谢一下了，哈哈 在手机上用git客户端进行编辑，并且是语音输入这样可以写文章了每天可以多写一下。测试一下。","link":"/2017/04/09/diary/My-New-Post/"},{"title":"New Year","text":"Today is the first day of a new year`s work start. this moment in every year,I will creat two plan.Study English hard and Work hard to lose weight.But never achieved before.So,When someone ask me:Do you have some plan in this year. I only answer: No. Maybe,I Can feel better in the coming year.Man always want too much, but do less.After all, is the first day started,It is best to have a list: Study English Lose weight","link":"/2018/02/26/diary/My-New-Year/"},{"title":"跑通全流程","text":"最近持续关注了一下github 周边的服务，不断的摸索，填坑，今天总算是能够跑个简单的流程。 现在还没有什么服务，只是简单的展示了一个service API. 但已经能够串联起来github + travis-CI + Azure 另外博客也用Travis 做了自动部署功能，用起来能简单一些，只需要提交到github上面就可以了 这个服务器会监听吗 好像修改文件是有问题的，再测试一次","link":"/2017/04/09/diary/test-post/"},{"title":"新的开始","text":"整理好github 的个人主页，做一个新的开始。 希望能多走几步。","link":"/2016/11/22/diary/新的开始/"},{"title":"痛苦的春天","text":"痛苦的春天失去了一切","link":"/2017/02/28/diary/痛苦的春天/"},{"title":"electron","text":"前端的桌面应用 ATOM VSCODE 都是基于这个东西做的。 还记得有个东西叫做node-webkit，NW atom-shell","link":"/2017/04/16/electron/electron/"},{"title":"开发技能评测工具","text":"如何在招聘中评测开发人员技能水平？以前有过一个技能评测平台的想法。当然，一般这种情况下别人都已经实现做成产品了。 How to Use Tests in Developer Recruitment – Itsquiz – Medium这篇文章也大概是这个思路，并且列举了一些技能测试平台，感觉非常不错。 今天被IKM虐了一遍，刚才又试用了一下itsquiz 改日再更新。","link":"/2018/12/13/interview/codeTest/"},{"title":"面试问题","text":"今年刚开始，做了很多面试工作，一个月下来都面试了有七八十人，接收到的简历来自中软、软通、易思博、埃森哲、易宝这些公司。大部分是电话面试，有一些是在现场的。一直想对这方面的工作做一下总结，指导后面工作。 面试方面写的比较好的文章 切图仔面试宝典 Node.js面试题之2017 破解前端面试（80% 应聘者不及格系列）：从闭包说起","link":"/2017/04/16/interview/面试问题概述/"},{"title":"java 术语","text":"Aspectj AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。 参考资料比较分析 Spring AOP 和 AspectJ 之间的差别 跟我学AspectJ（一） 什么是事务？ 我们在开发企业应用时，对于业务人员的一个操作实际是对数据读写的多步操作的结合。由于数据操作在顺序执行的过程中，任何一步操作都有可能发生异常，异常会导致后续操作无法完成，此时由于业务逻辑并未正确的完成，之前成功操作数据的并不可靠，需要在这种情况下进行回退。 事务的作用就是为了保证用户的每一个操作都是可靠的，事务中的每一步操作都必须成功执行，只要有发生异常就回退到事务开始未进行操作的状态。 事务管理是Spring框架中最为常用的功能之一，我们在使用Spring Boot开发应用时，大部分情况下也都需要使用事务。","link":"/2017/04/16/java/术语列表/"},{"title":"es6 技术","text":"记录一些es6 技术方面的事情","link":"/2017/01/09/javascript/es6-技术/"},{"title":"js 框架库列表收集","text":"年终盘点！2016 年 50 个最佳的轻量级 JavaScript 框架和库 - 知乎专栏 2017 年 3 月：15 个有趣的 JS 和 CSS 库 - 知乎专栏 2017 年 6 月：15 个有趣的 JS 和 CSS 库 - 知乎专栏","link":"/2017/06/25/javascript/jsframework/"},{"title":"js 优秀文章列表","text":"JavaScript的功能是不是都是靠C或者C++这种编译语言提供的？各JavaScript引擎的简介，及相关资料/博客收集帖","link":"/2021/12/23/javascript/优秀文章/"},{"title":"javascript 技术前沿","text":"JSPM systemjs systemjs 是一个最小系统加载工具，用来创建插件来处理可替代的场景加载过程，包括加载 CSS 场景和图片，主要运行在浏览器和 NodeJS 中。它是 ES6 浏览器加载程序的的扩展，将应用在本地浏览器中。通常创建的插件名称是模块本身，要是没有特意指定用途，则默认插件名是模块的扩展名称。 通常它支持创建的插件种类有： CSS System.import(‘my/file.css!’)Image System.import(‘some/image.png!image’)JSON System.import(‘some/data.json!’).then(function(json){})Markdown System.import(‘app/some/project/README.md!’).then(function(html) {})Text System.import(‘some/text.txt!text’).then(function(text) {})WebFont System.import(‘google Port Lligat Slab, Droid Sans !font’)","link":"/2017/04/16/javascript/技术前沿/"},{"title":"Linear Algebra","text":"麻省理工公开课：线性代数全35集网易公开课 Linear Algebra | Mathematics | MIT OpenCourseWare Related Resources | Linear Algebra | Mathematics | MIT OpenCourseWare","link":"/2017/06/10/math/线性代数/"},{"title":"mysql 密码重置","text":"linux停止mysql服务 service mysqld stop启动mysqld_safe ，跳过启动授权表。启动时加上skip-grant-tables参数目的是在启动mysql时不启动grant-tables，授权表。这样就可以修改root的密码了。 mysqld_safe –skip-grant-tables &amp; 登录mysql，并修改密码： mysql -uroot -p —-要求输入密码时，直接回车即可。 use mysql;update user set password=PASSWORD(‘12345678’) where user=”root”; —将root密码设置为12345678 flush privileges;quit 杀死mysqld_safe进程，并重启mysqld。 kill -9 11283 (11283为mysqld_safe进程）service mysqld startmysql -uroot -p (输入密码12345678即可）windows1、首先停止正在运行的MySQL进程复制代码 代码如下: net stop mysql 如未加载为服务，可直接在进程管理器或者服务中进行关闭。 2、以安全模式启动MySQL进入mysql目录在命令行下运行复制代码 代码如下: d:cd xampp/mysql/binmysqld.exe –skip-grant-tables 3、完成以后就可以不用密码进入MySQL了复制代码 代码如下: mysql -u root -p 提示输入密码时直接回车即可。 4、更改密码复制代码 代码如下: use mysqlupdate user set Password=password(‘新密码’) where User=’root’;flush privileges; 5、启动MySQL服务在任务管理器里关闭所有MySQL的进程，使用下面的命令启动。复制代码 代码如下: net start mysql","link":"/2017/04/16/mysql/密码重置/"},{"title":"Node 8","text":"端午节，node 8 版本更新 ,当然我写这个时候收到了8.1的邮件。 自然有人写了很多文章http://2ality.com/2017/05/util-promisify.html https://zhuanlan.zhihu.com/p/27173859?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io","link":"/2017/06/10/nodejs/node8/"},{"title":"nodejs 离线安装","text":"npmbox","link":"/2017/04/16/nodejs/离线安装/"},{"title":"用到的npm库介绍 第一期 (每周15库)","text":"计划整理一下会用到的一些npm库，每周做一期。 希望能够使用这个办法扩展思路，了解到更多的js技术方向。 如果关于这个注意你有更好的想法，欢迎在这里讨论 关键字提示字符截取：isaacs/abbrev-js: Like ruby’s Abbrev module terminal 颜色：doowb/ansi-colors: Easily add ANSI colors to your text and symbols in the terminal. Used by webpack, gulp, and many others! accepts 这条线路没有搞明白。内容协商？accepts - npmnegotiator - npm 编译语言模板统一结构，没有理解 :smiley:accord - npm 一个小型的js的解析器，有解析jsx 的插件，看起来非常不错，要是自己写模板解析器估计可以参考这个东西 :+1:acorn - npm zip 数据压缩方向adm-zip - npm after 没有考虑明白的一个库, 流程控制？回调函数？after - npm agent-base 一个过于http.agent 的一个扩展agent-base - npm ajv json 结构验证器，可以用于浏览器ajv - npm align-text 对齐字符串align-text - npm alphanum-sort 字母排序算法alphanum-sort - npm 用来实现atob btoa 64位解码abab - npm Get current machine IP, MAC and DNS servers.address - npm 做文本匹配，看起来比较常用在路径匹配方向上anymatch - npm append-transform，我并没有很好的理解这个意思append-transform - npm","link":"/2018/12/09/npm/2018-12-1/"},{"title":"python","text":"Python开发简单爬虫_python爬虫入门教程_python爬虫视频教程-慕课网","link":"/2017/06/12/python/python/"},{"title":"spring","text":"Detecting a Device可以判断你使用的是什么设备","link":"/2017/04/16/spring/官方实例说明/"},{"title":"数据库基础知识","text":"视图（View）是从一个或多个表（或视图）导出的表。视图与表（有时为与视图区别，也称表为基本表——Base Table）不同，视图是一个虚表，即视图所对应的数据不进行实际存储，数据库中只存储视图的定义，在对视图的数据进行操作时，系统根据视图的定义去操作与视图相关联的基本表。 视图是虚表，是从一个或几个基本表（或视图）中导出的表，在系统的数据字典中仅存放了视图的定义，不存放视图对应的数据。视图是原始数据库数据的一种变换，是查看表中数据的另外一种方式。可以将视图看成是一个移动的窗口，通过它可以看到感兴趣的数据。 视图是从一个或多个实际表中获得的，这些表的数据存放在数据库中。那些用于产生视图的表叫做该视图的基表。一个视图也可以从另一个视图中产生。视图的定义存在数据库中，与此定义相关的数据并没有再存一份于数据库中。通过视图看到的数据存放在基表中。视图看上去非常像数据库的物理表，对它的操作同任何其它的表一样。当通过视图修改数据时，实际上是在改变基表中的数据；相反地，基表数据的改变也会自动反映在由基表产生的视图中。由于逻辑上的原因，有些视图可以修改对应的基表，而有些则不能（仅仅能查询）。","link":"/2017/04/16/sql/View/"},{"title":"常用数据库列表","text":"数据库列表列出平时见过的一些数据库 gemfireGemfire作为内存数据库 JPAJPA全称Java Persistence API.JPA通过JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中 MongodbNeo4jNeo4j是一个高性能的,NOSQL图形数据库，它将结构化数据存储在网络上而不是表中。它是一个嵌入式的、基于磁盘的、具备完全的事务特性的Java持久化引擎，但是它将结构化数据存储在网络(从数学角度叫做图)上而不是表中。Neo4j也可以被看作是一个高性能的图引擎，该引擎具有成熟数据库的所有特性。程序员工作在一个面向对象的、灵活的网络结构下而不是严格、静态的表中——但是他们可以享受到具备完全的事务特性、企业级的数据库的所有好处。Neo4j因其嵌入式、高性能、轻量级等优势，越来越受到关注 Rest","link":"/2017/04/16/sql/常用数据库列表/"},{"title":"chrome 使用技巧","text":"Chrome DevTools 代码覆盖率功能详解 手把手教你开发chrome扩展一：开发Chrome Extenstion其实很简单 - walkingp - 博客园 Chrome插件开发-网页中运行自己的JS - 博客频道 - CSDN.NET 【chrome 插件一】开发一个简单chrome浏览器插件 - 推酷 2017-04-16 13:10:35","link":"/2017/06/11/tools/chrome/"},{"title":"gitlab 及其他","text":"平时在家github用的多些，在单位就主要是gitlab了。实际上gitlab.com 功能也很多。有些不想开源的项目就可以放在上面。 最近热衷于CI，今天再单位将gitlab的RUNNER配置成功了，后面好好用起来看下效果。 想着将hexo的博客好好研究一下，可以增加点评论功能，换个不太一样的皮肤","link":"/2017/04/14/tools/gitlab/"},{"title":"linux","text":"top命令能显示系统内存。目前常用的Linux下查看内容的专用工具是free命令。下面是对内存查看free命令输出内容的解释：total：总计物理内存的大小。used：已使用多大。free：可用有多少。Shared：多个进程共享的内存总额。Buffers/cached：磁盘缓存的大小。 查看版本号lsb_release -a Ubuntu常用命令大全Linux系统管理操作系统_希赛网 【Linux】Linux中常用操作命令 - 大牛笔记 - 博客园","link":"/2017/01/15/tools/linux/"},{"title":"maven","text":"记录maven 相关知识配置本地仓库123&lt;settings&gt; &lt;localRepository&gt;D:\\maven_new_repository&lt;/localRepository&gt; &lt;/settings&gt; 参考文章maven 仓库详解 mvn仓库https://mvnrepository.com/","link":"/2017/04/16/tools/maven/"},{"title":"sublime 常用工具","text":"sublime 常用插件说明好像专门建了一个工程搞这个事情，不过现在用sublime用的少了。","link":"/2017/04/16/tools/sublime/"},{"title":"vim","text":"vim简单使用教程 - 走在大牛的路上 - 博客园","link":"/2019/12/12/tools/vim/"},{"title":"vscode","text":"vscode我感觉这个方面会有大的发展。。所以最近在用这个，sublime 更新的太慢，再过几年可能跟不上潮流了。 常用插件整理","link":"/2017/04/16/tools/vscode/"},{"title":"工具技能盘点","text":"最近两年切换了很多工具，每个工具都涉及到了很多插件之类，之前在github上面整理了一次。想着再以文档的形式整理出来。 2017-06-05 23:29:39 工具方面的文章： 安卓方面：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2017/0526/7973.html","link":"/2017/06/05/tools/工具技能盘点/"},{"title":"工具插件开发","text":"JavaScript 或者说是es 实际上可以做很多软件的插件开发， 我大概知道有ps 3dsmax 的插件开发，语法都是es的一个子集。 之前用sublime的时候，写过一些代码提示的东西，比较简单，容易上手。最近在用vscode，希望能够写一些复杂的插件，真正的能够流行起来。代码提示这块目前有两个想法，一个是echar的代码提示工具，另外一个就是angular的uirouter，觉得都可以做出来。","link":"/2017/04/13/tools/工具插件开发/"},{"title":"前端工程","text":"大公司里怎样开发和部署前端代码？","link":"/2017/04/16/前端知识/前端工程/"},{"title":"前端新技术","text":"http://jspm.io/ http://c3js.org/ https://en.bem.info/methodology/","link":"/2021/12/23/前端知识/新技术/"},{"title":"SSL 概述","text":"http://baike.baidu.com/link?url=rUGT5db60PRyHom-3zlX66fa63kV9zVaQuGruNvt-cqinHwA2PKFQh6ArIWbzWk9qC0WX_CHuCBI228uuyExEq SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为网络通信提供安全及数据完整性的一种安全协议。TLS与SSL在传输层对网络连接进行加密。 Secure Socket Layer，为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。一般通用之规格为40 bit之安全标准，美国则已推出128 bit之更高安全标准，但限制出境。只要3.0版本以上之I.E.或Netscape浏览器即可支持SSL。当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。SSL协议可分为两层： SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持。 SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。","link":"/2017/04/15/计算机基础知识/SSL/"},{"title":"YAML","text":"YAML是“另一种标记语言”的外语缩写[1] （见前方参考资料原文内容）；但为了强调这种语言以数据做为中心，而不是以置标语言为重点，而用返璞词重新命名。它是一种直观的能够被电脑识别的数据序列化格式，是一个可读性高并且容易被人类阅读，容易和脚本语言交互，用来表达资料序列的编程语言。它是类似于标准通用标记语言的子集XML的数据描述语言，语法比XML简单很多。 参考： YAML 语言教程-阮一峰的网络日志","link":"/2017/01/15/计算机基础知识/YAML/"},{"title":"java annotation","text":"注解（Annotation），也叫元数据。一种代码级别的说明。它是JDK1.5及以后版本引入的一个特性，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。 作用分类：①编写文档：通过代码里标识的元数据生成文档【生成文档doc文档】② 代码分析：通过代码里标识的元数据对代码进行分析【使用反射】③编译检查：通过代码里标识的元数据让编译器能够实现基本的编译检查【Override】 常见注解@Override它的作用是对覆盖超类中方法的方法进行标记，如果被标记的方法并没有实际覆盖超类中的方法，则编译器会发出错误警告。 @Deprecated它的作用是对不应该再使用的方法添加注解，当编程人员使用这些方法时，将会在编译时显示提示信息，它与javadoc里的@deprecated标记有相同的功能，准确的说，它还不如javadoc @deprecated，因为它不支持参数，使用@Deprecated的示例代码示例如下： @SuppressWarnings其参数有：deprecation，使用了过时的类或方法时的警告unchecked，执行了未检查的转换时的警告fallthrough，当 switch 程序块直接通往下一种情况而没有 break 时的警告path，在类路径、源文件路径等中有不存在的路径时的警告serial，当在可序列化的类上缺少serialVersionUID 定义时的警告finally ，任何 finally 子句不能正常完成时的警告all，关于以上所有情况的警告 注解的分类自定义注解参考文章深入理解Java：注解（Annotation）自定义注解入门http://www.cnblogs.com/peida/archive/2013/04/24/3036689.html","link":"/2017/04/16/java/base/Annotation/"},{"title":"java scanner","text":"java.util.Scanner是Java5的新特征，主要功能是简化文本扫描。这个类最实用的地方表现在获取控制台输入，其他的功能都很鸡肋，尽管Java API文档中列举了大量的API方法，但是都不怎么地 一、扫描控制台输入 这个例子是常常会用到，但是如果没有Scanner，你写写就知道多难受了。当通过new Scanner(System.in)创建一个Scanner，控制台会一直等待输入，直到敲回车键结束，把所输入的内容传给Scanner，作为扫描对象。如果要获取输入的内容，则只需要调用Scanner的nextLine()方法即可。 /** 扫描控制台输入 @author leizhimin 2009-7-24 11:24:47*/public class TestScanner { public static void main(String[] args) { Scanner s = new Scanner(System.in); System.out.println(&quot;请输入字符串：&quot;); while (true) { String line = s.nextLine(); if (line.equals(&quot;exit&quot;)) break; System.out.println(&quot;&gt;&gt;&gt;&quot; + line); } } } 请输入字符串：234 234werwerbyebyeexit Process finished with exit code 0 先写这里吧，有空再继续完善。 二、如果说Scanner使用简便，不如说Scanner的构造器支持多种方式，构建Scanner的对象很方便。 可以从字符串（Readable）、输入流、文件等等来直接构建Scanner对象，有了Scanner了，就可以逐段（根据正则分隔式）来扫描整个文本，并对扫描后的结果做想要的处理。 三、Scanner默认使用空格作为分割符来分隔文本，但允许你指定新的分隔符 使用默认的空格分隔符： public static void main(String[] args) throws FileNotFoundException { Scanner s = new Scanner(“123 asdf sd 45 789 sdf asdfl,sdf.sdfl,asdf ……asdfkl las”);// s.useDelimiter(“ |,|\\.”); while (s.hasNext()) { System.out.println(s.next()); } } 123asdfsd45789sdfasdfl,sdf.sdfl,asdf……asdfkllas Process finished with exit code 0 将注释行去掉，使用空格或逗号或点号作为分隔符，输出结果如下：123asdfsd45789sdfasdflsdfsdflasdf asdfkl las Process finished with exit code 0 四、一大堆API函数，实用的没几个 （很多API，注释很让人迷惑，几乎毫无用处，这个类就这样被糟蹋了，启了很不错的名字，实际上做的全是龌龊事） 下面这几个相对实用： delimiter() 返回此 Scanner 当前正在用于匹配分隔符的 Pattern。hasNext() 判断扫描器中当前扫描位置后是否还存在下一段。（原APIDoc的注释很扯淡）hasNextLine() 如果在此扫描器的输入中存在另一行，则返回 true。next() 查找并返回来自此扫描器的下一个完整标记。nextLine() 此扫描器执行当前行，并返回跳过的输入信息。 五、逐行扫描文件，并逐行输出 看不到价值的扫描过程 public static void main(String[] args) throws FileNotFoundException { InputStream in = new FileInputStream(new File(“C:\\AutoSubmit.java”)); Scanner s = new Scanner(in); while(s.hasNextLine()){ System.out.println(s.nextLine()); } } package own; import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.InputStream;import java.io.InputStreamReader;import java.io.OutputStreamWriter;import java.net.HttpURLConnection;import java.net.ProtocolException;import java.net.URL; import com.verisign.uuid.UUID; /** @author wangpeng */public class AutoSubmit { /** @param args @throws Exception*/public static void main(String[] args) throws Exception { …在此省略N行 Process finished with exit code 0 Java对字符串支持还是比较弱的，尽管Java一直在努力。 参考文献http://bbs.itheima.com/thread-90856-1-1.html","link":"/2017/04/16/java/base/Scanner/"},{"title":"java IO","text":"示例代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235package cn.edu.tongji.cims.wade.system; import java.io.*; public class FileOperate { public FileOperate() { } /** * 新建目录 * @param folderPath String 如 c:/fqf * @return boolean */ public void newFolder(String folderPath) { try { String filePath = folderPath; filePath = filePath.toString(); java.io.File myFilePath = new java.io.File(filePath); if (!myFilePath.exists()) { myFilePath.mkdir(); } } catch (Exception e) { System.out.println(\"新建目录操作出错\"); e.printStackTrace(); } } /** * 新建文件 * @param filePathAndName String 文件路径及名称 如c:/fqf.txt * @param fileContent String 文件内容 * @return boolean */ public void newFile(String filePathAndName, String fileContent) { try { String filePath = filePathAndName; filePath = filePath.toString(); File myFilePath = new File(filePath); if (!myFilePath.exists()) { myFilePath.createNewFile(); } FileWriter resultFile = new FileWriter(myFilePath); PrintWriter myFile = new PrintWriter(resultFile); String strContent = fileContent; myFile.println(strContent); resultFile.close(); } catch (Exception e) { System.out.println(\"新建目录操作出错\"); e.printStackTrace(); } } /** * 删除文件 * @param filePathAndName String 文件路径及名称 如c:/fqf.txt * @param fileContent String * @return boolean */ public void delFile(String filePathAndName) { try { String filePath = filePathAndName; filePath = filePath.toString(); java.io.File myDelFile = new java.io.File(filePath); myDelFile.delete(); } catch (Exception e) { System.out.println(\"删除文件操作出错\"); e.printStackTrace(); } } /** * 删除文件夹 * @param filePathAndName String 文件夹路径及名称 如c:/fqf * @param fileContent String * @return boolean */ public void delFolder(String folderPath) { try { delAllFile(folderPath); //删除完里面所有内容 String filePath = folderPath; filePath = filePath.toString(); java.io.File myFilePath = new java.io.File(filePath); myFilePath.delete(); //删除空文件夹 } catch (Exception e) { System.out.println(\"删除文件夹操作出错\"); e.printStackTrace(); } } /** * 删除文件夹里面的所有文件 * @param path String 文件夹路径 如 c:/fqf */ public void delAllFile(String path) { File file = new File(path); if (!file.exists()) { return; } if (!file.isDirectory()) { return; } String[] tempList = file.list(); File temp = null; for (int i = 0; i &lt; tempList.length; i++) { if (path.endsWith(File.separator)) { temp = new File(path + tempList[i]); } else { temp = new File(path + File.separator + tempList[i]); } if (temp.isFile()) { temp.delete(); } if (temp.isDirectory()) { delAllFile(path+\"/\"+ tempList[i]);//先删除文件夹里面的文件 delFolder(path+\"/\"+ tempList[i]);//再删除空文件夹 } } } /** * 复制单个文件 * @param oldPath String 原文件路径 如：c:/fqf.txt * @param newPath String 复制后路径 如：f:/fqf.txt * @return boolean */ public void copyFile(String oldPath, String newPath) { try { int bytesum = 0; int byteread = 0; File oldfile = new File(oldPath); if (oldfile.exists()) { //文件存在时 InputStream inStream = new FileInputStream(oldPath); //读入原文件 FileOutputStream fs = new FileOutputStream(newPath); byte[] buffer = new byte[1444]; int length; while ( (byteread = inStream.read(buffer)) != -1) { bytesum += byteread; //字节数 文件大小 System.out.println(bytesum); fs.write(buffer, 0, byteread); } inStream.close(); } } catch (Exception e) { System.out.println(\"复制单个文件操作出错\"); e.printStackTrace(); } } /** * 复制整个文件夹内容 * @param oldPath String 原文件路径 如：c:/fqf * @param newPath String 复制后路径 如：f:/fqf/ff * @return boolean */ public void copyFolder(String oldPath, String newPath) { try { (new File(newPath)).mkdirs(); //如果文件夹不存在 则建立新文件夹 File a=new File(oldPath); String[] file=a.list(); File temp=null; for (int i = 0; i &lt; file.length; i++) { if(oldPath.endsWith(File.separator)){ temp=new File(oldPath+file[i]); } else{ temp=new File(oldPath+File.separator+file[i]); } if(temp.isFile()){ FileInputStream input = new FileInputStream(temp); FileOutputStream output = new FileOutputStream(newPath + \"/\" + (temp.getName()).toString()); byte[] b = new byte[1024 * 5]; int len; while ( (len = input.read(b)) != -1) { output.write(b, 0, len); } output.flush(); output.close(); input.close(); } if(temp.isDirectory()){//如果是子文件夹 copyFolder(oldPath+\"/\"+file[i],newPath+\"/\"+file[i]); } } } catch (Exception e) { System.out.println(\"复制整个文件夹内容操作出错\"); e.printStackTrace(); } } /** * 移动文件到指定目录 * @param oldPath String 如：c:/fqf.txt * @param newPath String 如：d:/fqf.txt */ public void moveFile(String oldPath, String newPath) { copyFile(oldPath, newPath); delFile(oldPath); } /** * 移动文件到指定目录 * @param oldPath String 如：c:/fqf.txt * @param newPath String 如：d:/fqf.txt */ public void moveFolder(String oldPath, String newPath) { copyFolder(oldPath, newPath); delFolder(oldPath); } }","link":"/2017/04/16/java/base/java.io.file/"},{"title":"java system 对象","text":"关于Java中使用的System对象，我们经常使用的是Systme.out.print ,而且也仅仅知道这是一个可以在控制台打印出语句，而没有去深究它的内在实现原理。下面我就详细地介绍System对象。 1.JDK中有如下定义：.The System class contains several useful class fields and methods. It cannot be instantiated.也就是说System对象是不能被实例化的，只能通过调用它的属性和方法来使用它。 2.System中的属性 Systme.in 是InputStream类型的，可以接受控制台输入的信息； System.out 和 System.err 都是PrintStream类型的 ，可以在控制台输出信息。 3.System.getProperties() 返回的是Properties类型的对象，而返回的信息是Java虚拟机启动过程中所要加载的环境配置信息。可以通过下面的代码获取和输出信息，由于Properties是HashTable的一个子类，因此可以通过Map方法取出该集合中的元素 Java代码[java] view plain copypackage javase.day18; import java.util.Properties; public class SystemDemo { public static void main(String[] args) { // TODO Auto-generated method stub Properties prop=System.getProperties(); for(Object key:prop.keySet()){ String keyStr=(String)key; String value=prop.getProperty(keyStr); System.out.println(keyStr+” — “+value); } }} 结果：控制台输出系统环境配置信息： java.runtime.name — Java(TM) SE Runtime Environmentsun.boot.library.path — C:\\Java\\developerEnv\\Java\\jdk1.6.0_16\\jre\\binjava.vm.version — 14.2-b01java.vm.vendor — Sun Microsystems Inc.java.vendor.url — http://java.sun.com/path.separator — ;java.vm.name — Java HotSpot(TM) Client VMfile.encoding.pkg — sun.iosun.java.launcher — SUN_STANDARDuser.country — CNsun.os.patch.level — Service Pack 3java.vm.specification.name — Java Virtual Machine Specificationuser.dir — D:\\workspace\\BlackHorsejava.runtime.version — 1.6.0_16-b01java.awt.graphicsenv — sun.awt.Win32GraphicsEnvironmentjava.endorsed.dirs — C:\\Java\\developerEnv\\Java\\jdk1.6.0_16\\jre\\lib\\endorsedos.arch — x86java.io.tmpdir — C:\\DOCUME~1\\CHENGR~1\\LOCALS~1\\Temp\\line.separator —…… ………… 使用以下代码也可以使控制台输出系统环境配置信息： [java] view plain copypublic class SystemDemo { public static void main(String[] args) { System.getProperties().list(System.out); }} 4.可以通过System对象在系统中自定义一些特有的信息：System.setProperty(myKey , myValue); 另外需要注意的一点是： 所谓的 system porperty，system 指的是 JRE (runtime)system，不是指 OS。System.setProperty(“net.jxta.tls.principal”, “client”);System.setProperty(“net.jxta.tls.password”, “password”);System.setProperty(“JXTA_HOME”,System.getProperty(“JXTA_HOME”,”client”));可以利用系统属性来加载多个驱动 参考http://blog.csdn.net/alex_zhuang/article/details/6918147 http://www.cnblogs.com/xuhuan/articles/1522212.html","link":"/2017/04/16/java/base/system/"},{"title":"java 注释1","text":"@see 类名@see 完整类名@see 完整类名#方法名 . @version格式如下：@version 版本信息其中，“版本信息”代表任何适合作为版本说明的资料。若在 javadoc 命令行使用了“ -version”标记，就会从生成的 HTML 文档里提取出版本信息。 @author格式如下：@author 作者信息其中，“作者信息”包括您的姓名、电子函件地址或者其他任何适宜的资料。若在javadoc 命令行使用了“ -author”标记，就会专门从生成的 HTML 文档里提取出作者信息。可为一系列作者使用多个这样的标记，但它们必须连续放置。全部作者信息会一起存入最终 HTML 代码的单独一个段落里","link":"/2017/04/16/java/base/注释/"},{"title":"java 线程","text":"线程安全比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成：1. 在 Items[Size] 的位置存放此元素；2. 增大 Size 的值。在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；而如果是在多线程情况下，比如有两个线程，线程 A 先将元素1存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B向此 ArrayList 添加元素2，因为此时 Size 仍然等于 0 （注意，我们假设的是添加一个元素是要两个步骤，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值，结果Size等于2。那好，我们来看看 ArrayList 的情况，期望的元素应该有2个，而实际只有一个元素，造成丢失元素，而且Size 等于 2。这就是“线程不安全”了。 原子操作“原子操作(atomic operation)是不需要synchronized”，这是Java多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切[1] 换到另一个线程）。 在多进程（线程）访问资源时，能够确保所有其他的进程（线程）都不在同一时间内访问相同的资源。原子操作（atomic operation）是不需要synchronized，这是Java多线程编程的老生常谈了。所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间不会有任何 context switch （切换到另一个线程）。通常所说的原子操作包括对非long和double型的primitive进行赋值，以及返回这两者之外的primitive。之所以要把它们排除在外是因为它们都比较大，而JVM的设计规范又没有要求读操作和赋值操作必须是原子操作（JVM可以试着去这么作，但并不保证）。首先处理器会自动保证基本的内存操作的原子性。处理器保证从系统内存当中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。奔腾6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作是原子的，但是复杂的内存操作处理器不能自动保证其原子性，比如跨总线宽度，跨多个缓存行，跨页表的访问。但是处理器提供总线锁定和缓存锁定两个机制来保证复杂内存操作的原子性。 原子操作是不可分割的，在执行完毕之前不会被任何其它任务或事件中断。在单处理器系统（UniProcessor）中，能够在单条指令中完成的操作都可以认为是” 原子操作”，因为中断只能发生于指令之间。这也是某些CPU指令系统中引入了test_and_set、test_and_clear等指令用于临界资源互斥的原因。但是，在对称多处理器（Symmetric Multi-Processor）结构中就不同了，由于系统中有多个处理器在独立地运行，即使能在单条指令中完成的操作也有可能受到干扰。我们以decl （递减指令）为例，这是一个典型的”读－改－写”过程，涉及两次内存访问。设想在不同CPU运行的两个进程都在递减某个计数值，可能发生的情况是：⒈ CPU A(CPU A上所运行的进程，以下同）从内存单元把当前计数值⑵装载进它的寄存器中；⒉ CPU B从内存单元把当前计数值⑵装载进它的寄存器中。⒊ CPU A在它的寄存器中将计数值递减为1；⒋ CPU B在它的寄存器中将计数值递减为1；⒌ CPU A把修改后的计数值⑴写回内存单元。⒍ CPU B把修改后的计数值⑴写回内存单元。我们看到，内存里的计数值应该是0，然而它却是1。如果该计数值是一个共享资源的引用计数，每个进程都在递减后把该值与0进行比较，从而确定是否需要释放该共享资源。这时，两个进程都去掉了对该共享资源的引用，但没有一个进程能够释放它–两个进程都推断出：计数值是1，共享资源仍然在被使用。","link":"/2017/04/16/java/base/线程/"},{"title":"","text":"java 8 中接口可以有方法体","link":"/2021/12/23/java/java8/java8新增功能汇总/"},{"title":"typeScript","text":"declare namespace interface readonly","link":"/2021/12/23/javascript/typescript/学习记录/"},{"title":"spirng 基础知识","text":"接口及面向接口编程什么是IOC控制反转自己不负责对象的创建和维护，由对方来创建，自己只是用。 获得依赖对象的过程被反转了。 DI依赖注入，是控制反转的实现方式 Spring的Bean配置IOC容器中所有的对象都称之为Bean Bean的初始化Spring 的常用注入方式","link":"/2017/04/16/spring/base/base/"},{"title":"eclipse","text":"eclipse 必装插件我平时会给eclipse 安装一些插件，做一下整理 emment eclipse plugin spring ide spring ide roo support spring tool suite (sts) spring source tool suite (sts) 导出配置项Eclipse的 File -&gt; Export（导出）,在窗口中展开 General（常规） -&gt; Perferences（首选项）–&gt;Export all（全部导出）然后点击 NEXT。然后点击”Browse（浏览）”选择任意的一个路径，保存配置文件，然后点击”Finish”。 代码提示abcdefghijklmnopqrstuvwxyzABCKEFGHIGKLMNOPQRSTUVWXYZ1234567890`1234567890-~!@#$%^&amp;*()_+[]、{}|’,./:”&lt;&gt;?","link":"/2017/04/16/tools/eclipse/eclipse/"},{"title":"eclipse","text":"SpringSource Tool SuiteSpringSource Tool Suite 基于 Spring IDE ，提供了其它的一些特性，如 基于Spring dm Server 的osgi 开发，及其它一些 Spring 项目的支持，如Spring Roo， Spring Batch等。 Spring Boot Dashboardcloud foundry 相关文章中文 安装相关http://www.itxxz.com/a/gaoji/2015/0120/eclipse_spring_tools.html http://blog.csdn.net/dhx20022889/article/details/38041039 官方 https://spring.io/tools/sts/all/ http://docs.spring.io/sts/nan/v380/NewAndNoteworthy.html","link":"/2017/04/16/tools/eclipse/sts/"},{"title":"git","text":"1.5 起步 - 初次运行 Git 前的配置 起步 - 初次运行 Git 前的配置初次运行 Git 前的配置一般在新的系统上，我们都需要先配置下自己的 Git 工作环境。配置工作只需一次，以后升级时还会沿用现在的配置。当然，如果需要，你随时可以用相同的命令修改已有的配置。 Git 提供了一个叫做 git config 的工具（译注：实际是 git-config 命令，只不过可以通过 git 加一个名字来呼叫此命令。），专门用来配置或读取相应的工作环境变量。而正是由这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方： /etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\\Documents and Settings\\$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 用户信息第一个要配置的是你个人的用户名称和电子邮件地址。这两条配置很重要，每次 Git 提交时都会引用这两条信息，说明是谁提交了更新，所以会随更新内容一起被永久纳入历史记录： $ git config –global user.name “John Doe”$ git config –global user.email johndoe@example.com如果用了 –global 选项，那么更改的配置文件就是位于你用户主目录下的那个，以后你所有的项目都会默认使用这里配置的用户信息。如果要在某个特定的项目中使用其他名字或者电邮，只要去掉 –global 选项重新配置即可，新的设定保存在当前项目的 .git/config 文件里。 文本编辑器接下来要设置的是默认使用的文本编辑器。Git 需要你输入一些额外消息的时候，会自动调用一个外部文本编辑器给你用。默认会使用操作系统指定的默认编辑器，一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置： $ git config –global core.editor emacs差异分析工具还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话： $ git config –global merge.tool vimdiffGit 可以理解 kdiff3，tkdiff，meld，xxdiff，emerge，vimdiff，gvimdiff，ecmerge，和 opendiff 等合并工具的输出信息。当然，你也可以指定使用自己开发的工具，具体怎么做可以参阅第七章。 查看配置信息要检查已有的配置信息，可以使用 git config –list 命令： $ git config –listuser.name=Scott Chaconuser.email=schacon@gmail.comcolor.status=autocolor.branch=autocolor.interactive=autocolor.diff=auto…有时候会看到重复的变量名，那就说明它们来自不同的配置文件（比如 /etc/gitconfig 和 ~/.gitconfig），不过最终 Git 实际采用的是最后一个。 也可以直接查阅某个环境变量的设定，只要把特定的名字跟在后面即可，像这样： $ git config user.nameScott Chacon","link":"/2017/04/16/tools/git/git/"},{"title":"github Services","text":"近期痴迷github 的 Services 系列，写一写相关介绍，和大家分享。 今天看起来官方已经将services 升级到顶部导航 成为 marketplace 了，估计算是商业模式上面的尝试变化吧。这些项目看起来都非常的炫酷和值得学习。官网列表已经很清楚的介绍了各个服务的类别之类，我主要对自己用到的做一些说明。比如CI 系列有很多，我只用了Travis 就只介绍这一个了。 Travis CI目前在CI 方面主要尝试了用travis，做了几个实验，看起来不错。 Coveralls主要是自动化测试覆盖率方面，还没有研究明白。 codeclimate这个是做代码检测方面的，看到文章说是要开源了 david-dm这个是用来查看包依赖关系的网站 snyk持续修复依赖关系，这个是什么鬼","link":"/2017/06/04/tools/git/github/"},{"title":"git 相关网站","text":"https://git.oschina.net https://github.com/ Github | 程序员七大生产力工具 - 知乎专栏 2017 年 4 月：前端与设计资源集 - 知乎专栏","link":"/2017/04/16/tools/git/website/"},{"title":"spring 优秀站点","text":"http://blog.didispace.com/ http://www.infoq.com/cn/articles/microframeworks1-spring-boot/ http://www.ibm.com/developerworks/cn/java/j-lo-spring-boot/ http://blog.didispace.com/springbootlog/","link":"/2017/04/16/spring/springboot/优秀站点/"},{"title":"spring boot 模块解析","text":"spring-boot-starter：核心模块，包括自动配置支持、日志和YAML spring-boot-starter-test：测试模块，包括JUnit、Hamcrest、Mockito spring-boot-starter-web","link":"/2017/04/16/spring/springboot/模块解析/"},{"title":"spring boot 知识点","text":"Spring Boot提供了默认配置的模板引擎主要有以下几种： ThymeleafFreeMarkerVelocityGroovyMustache 工程结构（最佳实践）com +- example +- myproject +- Application.java | +- domain | +- Customer.java | +- CustomerRepository.java | +- service | +- CustomerService.java | +- web | +- CustomerController.java |","link":"/2017/04/16/spring/springboot/知识点/"},{"title":"spring mvc 简介","text":"Spring MVC简介","link":"/2017/04/16/spring/mvc/相关文章/"},{"title":"Spring Cloud","text":"周立|Spring Cloud Spring Cloud简介 Spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。 Spring Cloud包含了多个子项目（针对分布式系统中涉及的多个不同开源产品），比如：Spring Cloud Config、Spring Cloud Netflix、Spring Cloud CloudFoundry、Spring Cloud AWS、Spring Cloud Security、Spring Cloud Commons、Spring Cloud Zookeeper、Spring Cloud CLI等项目。 微服务架构 “微服务架构”在这几年非常的火热，以至于关于微服务架构相关的产品社区也变得越来越活跃（比如：netflix、dubbo），Spring Cloud也因Spring社区的强大知名度和影响力也被广大架构师与开发者备受关注。 那么什么是“微服务架构”呢？简单的说，微服务架构就是将一个完整的应用从数据存储开始垂直拆分成多个不同的服务，每个服务都能独立部署、独立维护、独立扩展，服务与服务间通过诸如RESTful API的方式互相调用。 对于“微服务架构”，大家在互联网可以搜索到很多相关的介绍和研究文章来进行学习和了解。也可以阅读始祖Martin Fowler的《Microservices》，本文不做更多的介绍和描述。 服务注册与发现 在简单介绍了Spring Cloud和微服务架构之后，下面回归本文的主旨内容，如何使用Spring Cloud搭建服务注册与发现模块。 这里我们会用到Spring Cloud Netflix，该项目是Spring Cloud的子项目之一，主要内容是对Netflix公司一系列开源产品的包装，它为Spring Boot应用提供了自配置的Netflix OSS整合。通过一些简单的注解，开发者就可以快速的在应用中配置一下常用模块并构建庞大的分布式系统。它主要提供的模块包括：服务发现（Eureka），断路器（Hystrix），智能路有（Zuul），客户端负载均衡（Ribbon）等。 所以，我们这里的核心内容就是服务发现模块：Eureka。下面我们动手来做一些尝试。","link":"/2017/04/16/spring/springcloud/overview/"},{"title":"java IO","text":"InputStreamreadByteArrayInputStreamFilterInputStream PipedInputStringPipedOutputStream SequenceInputStreamEnumeration DataInputStreamDataOutputStream OutputStreamwriteFilterOutputStreamByteArrayOutputStreamPipedOutputStream DecoratorRandomAccessFile File文件和目录路径名的抽象表示形式。 FilenameFilter实现此接口的类实例可用于过滤器文件名。","link":"/2017/04/16/java/base/IO/overview/"},{"title":"java collection","text":"Collection 接口 是List Set Queue接口的父接口 定义了可用于操作List Set Queue 的方法 - 增删改查 List接口及其实现类 ArrayListList 是元素有序并且可以重复的集合，被称为序列 Lsit 可以精确的控制每个元素插入的位置，或删除某个元素的位置 ArrayList数组序列，是List的一个重要实现类 SetSet 中的对象不可重复，Set 可以添加空对象","link":"/2017/04/16/java/base/集合/collection/"},{"title":"java map","text":"Map提供了一种映射关系， map 中的键值对一Entry类型的对象实例形式存在map 支持泛型 HashMap 类HashMap是Map的一个重要的实现类，也是最常用的，基于哈希表实现 key值和value值都可以为null，但是一个HashMap只能有一个key值为null的映射，key不可以重复","link":"/2017/04/16/java/base/集合/map/"},{"title":"java 泛型","text":"泛型只是规定某个集合只可以存放特定类型的对象 并且会在编译期间进行类型检查 只可以直接按指定类型获取集合元素，或者子类型 泛型不能使基本类型，必须是引用类型的，不能使基础类型的。 如果一定要用基础类型，必须使用基础类型的包装类 int — Integer long — Long boolean — Boolean","link":"/2017/04/16/java/base/集合/泛型/"},{"title":"java 集合","text":"作用 在类的内部对数据进行组织 简单快速的搜索大数量的条目 有的集合接口，提供一些列排列有序的元素，并且可以再序列件快速的插入或者删除有关元素 有的集合接口，提供了映射关系，可以通过key快速查找到对应的唯一对象，而且这个关键字可以使任意类型的 数组，数组的长度是固定的，集合的长度和容量可以动态扩展 数组只能通过下标访问，为整形的，只能通过遍历筛选，而集合提供了映射关系，可以方便查找 java 集合框架collection 家族 根接口list 常用 排列有序 序列list 实现类Arraylist 数组序列LinkedList 链表 queue 排列有序 队列LinkedList 链表 set 排列无序 集HashSet 哈希集 map 家族HashMap 哈希表 存储特点collection存储的是一个一个的对象 mapEntry 为map的内部类 键值对key value 为一个映射， Entry 类的实例 使用频率Arraylist HashSet HashMap","link":"/2017/04/16/java/base/集合/集合/"}],"tags":[{"name":"javascript","slug":"javascript","link":"/tags/javascript/"},{"name":"日志","slug":"日志","link":"/tags/日志/"},{"name":"画画","slug":"画画","link":"/tags/画画/"},{"name":"码农茶社","slug":"码农茶社","link":"/tags/码农茶社/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"movie","slug":"movie","link":"/tags/movie/"},{"name":"idea","slug":"idea","link":"/tags/idea/"},{"name":"unity","slug":"unity","link":"/tags/unity/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"Security","slug":"Security","link":"/tags/Security/"},{"name":"多媒体","slug":"多媒体","link":"/tags/多媒体/"},{"name":"Machine-learning","slug":"Machine-learning","link":"/tags/Machine-learning/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"angular","slug":"angular","link":"/tags/angular/"},{"name":"cloud","slug":"cloud","link":"/tags/cloud/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"diary","slug":"diary","link":"/tags/diary/"},{"name":"electron","slug":"electron","link":"/tags/electron/"},{"name":"-面试","slug":"面试","link":"/tags/面试/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Mathematics","slug":"Mathematics","link":"/tags/Mathematics/"},{"name":"nodejs","slug":"nodejs","link":"/tags/nodejs/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"Tools","slug":"Tools","link":"/tags/Tools/"},{"name":"linux","slug":"linux","link":"/tags/linux/"},{"name":"sublime","slug":"sublime","link":"/tags/sublime/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"前端知识","slug":"前端知识","link":"/tags/前端知识/"},{"name":"基础","slug":"基础","link":"/tags/基础/"},{"name":"typeScript","slug":"typeScript","link":"/tags/typeScript/"},{"name":"eclipse","slug":"eclipse","link":"/tags/eclipse/"},{"name":"tools","slug":"tools","link":"/tags/tools/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"website","slug":"website","link":"/tags/website/"},{"name":"srping","slug":"srping","link":"/tags/srping/"}],"categories":[{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"movie","slug":"movie","link":"/categories/movie/"},{"name":"idea","slug":"idea","link":"/categories/idea/"},{"name":"unity","slug":"unity","link":"/categories/unity/"},{"name":"Machine-learning","slug":"Machine-learning","link":"/categories/Machine-learning/"},{"name":"angular","slug":"angular","link":"/categories/angular/"},{"name":"diary","slug":"diary","link":"/categories/diary/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"Mathematics","slug":"Mathematics","link":"/categories/Mathematics/"},{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"计算机基础","slug":"计算机基础","link":"/categories/计算机基础/"},{"name":"typeScript","slug":"typeScript","link":"/categories/typeScript/"}]}